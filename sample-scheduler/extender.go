package main

import (
	"fmt"
	"math/rand"
)

// Extender is an interface for external processes to influence scheduling
// decisions made by Kubernetes. This is typically needed for resources not directly
// managed by Kubernetes.
type Extender interface {
	// Name returns a unique name that identifies the extender.
	Name() string

	// Filter based on extender-implemented predicate functions. The filtered list is
	// expected to be a subset of the supplied list.
	// The failedNodes and failedAndUnresolvableNodes optionally contains the list
	// of failed nodes and failure reasons, except nodes in the latter are
	// unresolvable.
	Filter(pod *Pod, nodes []*Node) (filteredNodes []*Node, err error)

	// Prioritize based on extender-implemented priority functions. The returned scores & weight
	// are used to compute the weighted score for an extender. The weighted scores are added to
	// the scores computed by Kubernetes scheduler. The total scores are used to do the host selection.
	Prioritize(pod *Pod, nodes []*Node) (hostPriorities []NodeScore, weight int64, err error)

	// Bind delegates the action of binding a pod to a node to the extender.
	// Bind(binding *Binding) error

	// IsBinder returns whether this extender is configured for the Bind method.
	IsBinder() bool

	// IsInterested returns true if at least one extended resource requested by
	// this pod is managed by this extender.
	IsInterested(pod *Pod) bool

	// ProcessPreemption returns nodes with their victim pods processed by extender based on
	// given:
	//   1. Pod to schedule
	//   2. Candidate nodes and victim pods (nodeNameToVictims) generated by previous scheduling process.
	// The possible changes made by extender may include:
	//   1. Subset of given candidate nodes after preemption phase of extender.
	//   2. A different set of victim pod for every given candidate node after preemption phase of extender.
	// ProcessPreemption(
	// 	pod *Pod,
	// 	nodeNameToVictims map[string]*extenderv1.Victims,
	// 	nodeInfos NodeInfoLister,
	// ) (map[string]*extenderv1.Victims, error)

	// SupportsPreemption returns if the scheduler extender support preemption or not.
	SupportsPreemption() bool

	// IsIgnorable returns true indicates scheduling should not fail when this extender
	// is unavailable. This gives scheduler ability to fail fast and tolerate non-critical extenders as well.
	IsIgnorable() bool
}

// NewHTTPExtender creates an HTTPExtender object.
func NewHTTPExtender() Extender {
	return &MyExtender{}
}

// MyExtender implements the Extender interface.
type MyExtender struct {
	extenderURL string
	ignorable   bool
	bindVerb    string
	preemptVerb string
}

// Name returns extenderURL to identify the extender.
func (h *MyExtender) Name() string {
	return h.extenderURL
}

// IsIgnorable returns true indicates scheduling should not fail when this extender
// is unavailable
func (h *MyExtender) IsIgnorable() bool {
	return h.ignorable
}

// IsBinder returns whether this extender is configured for the Bind method.
func (h *MyExtender) IsBinder() bool {
	return h.bindVerb != ""
}

func (h *MyExtender) SupportsPreemption() bool {
	return len(h.preemptVerb) > 0
}

// IsInterested returns true if at least one extended resource requested by
// this pod is managed by this extender.
func (h *MyExtender) IsInterested(pod *Pod) bool {
	return true
}

func (h *MyExtender) Filter(pod *Pod, nodes []*Node) (filteredNodes []*Node, err error) {
	for _, node := range nodes {
		r := rand.Intn(2)
		if r == 0 {
			fmt.Printf("pod %s is unlucky to fit node %s\n", pod.name, node.name)
		} else {
			filteredNodes = append(filteredNodes, node)
		}
	}

	return filteredNodes, nil
}

func (h *MyExtender) Prioritize(pod *Pod, nodes []*Node) (hostPriorities []NodeScore, weight int64, err error) {
	for i, node := range nodes {
		hostPriorities = append(hostPriorities, NodeScore{node.name, int64(i)})
	}

	return hostPriorities, 1, nil
}
